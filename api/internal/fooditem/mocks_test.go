// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package fooditem_test

import (
	mock "github.com/stretchr/testify/mock"
	"github.com/vidarandrebo/nutrition-tracker/api/internal/fooditem"
)

// NewMockIRepository creates a new instance of MockIRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIRepository(t interface {
	mock.TestingT
	Cleanup(func())
},
) *MockIRepository {
	mock := &MockIRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIRepository is an autogenerated mock type for the IRepository type
type MockIRepository struct {
	mock.Mock
}

type MockIRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIRepository) EXPECT() *MockIRepository_Expecter {
	return &MockIRepository_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type MockIRepository
func (_mock *MockIRepository) Add(item fooditem.TableFoodItem) (fooditem.TableFoodItem, error) {
	ret := _mock.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 fooditem.TableFoodItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(fooditem.TableFoodItem) (fooditem.TableFoodItem, error)); ok {
		return returnFunc(item)
	}
	if returnFunc, ok := ret.Get(0).(func(fooditem.TableFoodItem) fooditem.TableFoodItem); ok {
		r0 = returnFunc(item)
	} else {
		r0 = ret.Get(0).(fooditem.TableFoodItem)
	}
	if returnFunc, ok := ret.Get(1).(func(fooditem.TableFoodItem) error); ok {
		r1 = returnFunc(item)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockIRepository_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - item fooditem.TableFoodItem
func (_e *MockIRepository_Expecter) Add(item interface{}) *MockIRepository_Add_Call {
	return &MockIRepository_Add_Call{Call: _e.mock.On("Add", item)}
}

func (_c *MockIRepository_Add_Call) Run(run func(item fooditem.TableFoodItem)) *MockIRepository_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 fooditem.TableFoodItem
		if args[0] != nil {
			arg0 = args[0].(fooditem.TableFoodItem)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_Add_Call) Return(tableFoodItem fooditem.TableFoodItem, err error) *MockIRepository_Add_Call {
	_c.Call.Return(tableFoodItem, err)
	return _c
}

func (_c *MockIRepository_Add_Call) RunAndReturn(run func(item fooditem.TableFoodItem) (fooditem.TableFoodItem, error)) *MockIRepository_Add_Call {
	_c.Call.Return(run)
	return _c
}

// AddMicronutrient provides a mock function for the type MockIRepository
func (_mock *MockIRepository) AddMicronutrient(item fooditem.TableMicronutrient) (fooditem.TableMicronutrient, error) {
	ret := _mock.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for AddMicronutrient")
	}

	var r0 fooditem.TableMicronutrient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(fooditem.TableMicronutrient) (fooditem.TableMicronutrient, error)); ok {
		return returnFunc(item)
	}
	if returnFunc, ok := ret.Get(0).(func(fooditem.TableMicronutrient) fooditem.TableMicronutrient); ok {
		r0 = returnFunc(item)
	} else {
		r0 = ret.Get(0).(fooditem.TableMicronutrient)
	}
	if returnFunc, ok := ret.Get(1).(func(fooditem.TableMicronutrient) error); ok {
		r1 = returnFunc(item)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_AddMicronutrient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMicronutrient'
type MockIRepository_AddMicronutrient_Call struct {
	*mock.Call
}

// AddMicronutrient is a helper method to define mock.On call
//   - item fooditem.TableMicronutrient
func (_e *MockIRepository_Expecter) AddMicronutrient(item interface{}) *MockIRepository_AddMicronutrient_Call {
	return &MockIRepository_AddMicronutrient_Call{Call: _e.mock.On("AddMicronutrient", item)}
}

func (_c *MockIRepository_AddMicronutrient_Call) Run(run func(item fooditem.TableMicronutrient)) *MockIRepository_AddMicronutrient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 fooditem.TableMicronutrient
		if args[0] != nil {
			arg0 = args[0].(fooditem.TableMicronutrient)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_AddMicronutrient_Call) Return(tableMicronutrient fooditem.TableMicronutrient, err error) *MockIRepository_AddMicronutrient_Call {
	_c.Call.Return(tableMicronutrient, err)
	return _c
}

func (_c *MockIRepository_AddMicronutrient_Call) RunAndReturn(run func(item fooditem.TableMicronutrient) (fooditem.TableMicronutrient, error)) *MockIRepository_AddMicronutrient_Call {
	_c.Call.Return(run)
	return _c
}

// AddPortionSize provides a mock function for the type MockIRepository
func (_mock *MockIRepository) AddPortionSize(item fooditem.TablePortionSize) (fooditem.TablePortionSize, error) {
	ret := _mock.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for AddPortionSize")
	}

	var r0 fooditem.TablePortionSize
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(fooditem.TablePortionSize) (fooditem.TablePortionSize, error)); ok {
		return returnFunc(item)
	}
	if returnFunc, ok := ret.Get(0).(func(fooditem.TablePortionSize) fooditem.TablePortionSize); ok {
		r0 = returnFunc(item)
	} else {
		r0 = ret.Get(0).(fooditem.TablePortionSize)
	}
	if returnFunc, ok := ret.Get(1).(func(fooditem.TablePortionSize) error); ok {
		r1 = returnFunc(item)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_AddPortionSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPortionSize'
type MockIRepository_AddPortionSize_Call struct {
	*mock.Call
}

// AddPortionSize is a helper method to define mock.On call
//   - item fooditem.TablePortionSize
func (_e *MockIRepository_Expecter) AddPortionSize(item interface{}) *MockIRepository_AddPortionSize_Call {
	return &MockIRepository_AddPortionSize_Call{Call: _e.mock.On("AddPortionSize", item)}
}

func (_c *MockIRepository_AddPortionSize_Call) Run(run func(item fooditem.TablePortionSize)) *MockIRepository_AddPortionSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 fooditem.TablePortionSize
		if args[0] != nil {
			arg0 = args[0].(fooditem.TablePortionSize)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_AddPortionSize_Call) Return(tablePortionSize fooditem.TablePortionSize, err error) *MockIRepository_AddPortionSize_Call {
	_c.Call.Return(tablePortionSize, err)
	return _c
}

func (_c *MockIRepository_AddPortionSize_Call) RunAndReturn(run func(item fooditem.TablePortionSize) (fooditem.TablePortionSize, error)) *MockIRepository_AddPortionSize_Call {
	_c.Call.Return(run)
	return _c
}

// CheckOwnership provides a mock function for the type MockIRepository
func (_mock *MockIRepository) CheckOwnership(id int64, ownerID int64) error {
	ret := _mock.Called(id, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for CheckOwnership")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int64, int64) error); ok {
		r0 = returnFunc(id, ownerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIRepository_CheckOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckOwnership'
type MockIRepository_CheckOwnership_Call struct {
	*mock.Call
}

// CheckOwnership is a helper method to define mock.On call
//   - id int64
//   - ownerID int64
func (_e *MockIRepository_Expecter) CheckOwnership(id interface{}, ownerID interface{}) *MockIRepository_CheckOwnership_Call {
	return &MockIRepository_CheckOwnership_Call{Call: _e.mock.On("CheckOwnership", id, ownerID)}
}

func (_c *MockIRepository_CheckOwnership_Call) Run(run func(id int64, ownerID int64)) *MockIRepository_CheckOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRepository_CheckOwnership_Call) Return(err error) *MockIRepository_CheckOwnership_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIRepository_CheckOwnership_Call) RunAndReturn(run func(id int64, ownerID int64) error) *MockIRepository_CheckOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockIRepository
func (_mock *MockIRepository) Delete(id int64) error {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int64) error); ok {
		r0 = returnFunc(id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockIRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - id int64
func (_e *MockIRepository_Expecter) Delete(id interface{}) *MockIRepository_Delete_Call {
	return &MockIRepository_Delete_Call{Call: _e.mock.On("Delete", id)}
}

func (_c *MockIRepository_Delete_Call) Run(run func(id int64)) *MockIRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_Delete_Call) Return(err error) *MockIRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIRepository_Delete_Call) RunAndReturn(run func(id int64) error) *MockIRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockIRepository
func (_mock *MockIRepository) Get(ownerID int64) ([]fooditem.TableFoodItem, error) {
	ret := _mock.Called(ownerID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []fooditem.TableFoodItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) ([]fooditem.TableFoodItem, error)); ok {
		return returnFunc(ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) []fooditem.TableFoodItem); ok {
		r0 = returnFunc(ownerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]fooditem.TableFoodItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockIRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ownerID int64
func (_e *MockIRepository_Expecter) Get(ownerID interface{}) *MockIRepository_Get_Call {
	return &MockIRepository_Get_Call{Call: _e.mock.On("Get", ownerID)}
}

func (_c *MockIRepository_Get_Call) Run(run func(ownerID int64)) *MockIRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_Get_Call) Return(tableFoodItems []fooditem.TableFoodItem, err error) *MockIRepository_Get_Call {
	_c.Call.Return(tableFoodItems, err)
	return _c
}

func (_c *MockIRepository_Get_Call) RunAndReturn(run func(ownerID int64) ([]fooditem.TableFoodItem, error)) *MockIRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockIRepository
func (_mock *MockIRepository) GetByID(id int64) (fooditem.TableFoodItem, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 fooditem.TableFoodItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (fooditem.TableFoodItem, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) fooditem.TableFoodItem); ok {
		r0 = returnFunc(id)
	} else {
		r0 = ret.Get(0).(fooditem.TableFoodItem)
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockIRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id int64
func (_e *MockIRepository_Expecter) GetByID(id interface{}) *MockIRepository_GetByID_Call {
	return &MockIRepository_GetByID_Call{Call: _e.mock.On("GetByID", id)}
}

func (_c *MockIRepository_GetByID_Call) Run(run func(id int64)) *MockIRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_GetByID_Call) Return(tableFoodItem fooditem.TableFoodItem, err error) *MockIRepository_GetByID_Call {
	_c.Call.Return(tableFoodItem, err)
	return _c
}

func (_c *MockIRepository_GetByID_Call) RunAndReturn(run func(id int64) (fooditem.TableFoodItem, error)) *MockIRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMicronutrients provides a mock function for the type MockIRepository
func (_mock *MockIRepository) GetMicronutrients(foodItemID int64) ([]fooditem.TableMicronutrient, error) {
	ret := _mock.Called(foodItemID)

	if len(ret) == 0 {
		panic("no return value specified for GetMicronutrients")
	}

	var r0 []fooditem.TableMicronutrient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) ([]fooditem.TableMicronutrient, error)); ok {
		return returnFunc(foodItemID)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) []fooditem.TableMicronutrient); ok {
		r0 = returnFunc(foodItemID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]fooditem.TableMicronutrient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(foodItemID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_GetMicronutrients_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMicronutrients'
type MockIRepository_GetMicronutrients_Call struct {
	*mock.Call
}

// GetMicronutrients is a helper method to define mock.On call
//   - foodItemID int64
func (_e *MockIRepository_Expecter) GetMicronutrients(foodItemID interface{}) *MockIRepository_GetMicronutrients_Call {
	return &MockIRepository_GetMicronutrients_Call{Call: _e.mock.On("GetMicronutrients", foodItemID)}
}

func (_c *MockIRepository_GetMicronutrients_Call) Run(run func(foodItemID int64)) *MockIRepository_GetMicronutrients_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_GetMicronutrients_Call) Return(tableMicronutrients []fooditem.TableMicronutrient, err error) *MockIRepository_GetMicronutrients_Call {
	_c.Call.Return(tableMicronutrients, err)
	return _c
}

func (_c *MockIRepository_GetMicronutrients_Call) RunAndReturn(run func(foodItemID int64) ([]fooditem.TableMicronutrient, error)) *MockIRepository_GetMicronutrients_Call {
	_c.Call.Return(run)
	return _c
}

// GetPortionSizes provides a mock function for the type MockIRepository
func (_mock *MockIRepository) GetPortionSizes(foodItemID int64) ([]fooditem.TablePortionSize, error) {
	ret := _mock.Called(foodItemID)

	if len(ret) == 0 {
		panic("no return value specified for GetPortionSizes")
	}

	var r0 []fooditem.TablePortionSize
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) ([]fooditem.TablePortionSize, error)); ok {
		return returnFunc(foodItemID)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) []fooditem.TablePortionSize); ok {
		r0 = returnFunc(foodItemID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]fooditem.TablePortionSize)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(foodItemID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIRepository_GetPortionSizes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPortionSizes'
type MockIRepository_GetPortionSizes_Call struct {
	*mock.Call
}

// GetPortionSizes is a helper method to define mock.On call
//   - foodItemID int64
func (_e *MockIRepository_Expecter) GetPortionSizes(foodItemID interface{}) *MockIRepository_GetPortionSizes_Call {
	return &MockIRepository_GetPortionSizes_Call{Call: _e.mock.On("GetPortionSizes", foodItemID)}
}

func (_c *MockIRepository_GetPortionSizes_Call) Run(run func(foodItemID int64)) *MockIRepository_GetPortionSizes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRepository_GetPortionSizes_Call) Return(tablePortionSizes []fooditem.TablePortionSize, err error) *MockIRepository_GetPortionSizes_Call {
	_c.Call.Return(tablePortionSizes, err)
	return _c
}

func (_c *MockIRepository_GetPortionSizes_Call) RunAndReturn(run func(foodItemID int64) ([]fooditem.TablePortionSize, error)) *MockIRepository_GetPortionSizes_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIService creates a new instance of MockIService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIService(t interface {
	mock.TestingT
	Cleanup(func())
},
) *MockIService {
	mock := &MockIService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIService is an autogenerated mock type for the IService type
type MockIService struct {
	mock.Mock
}

type MockIService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIService) EXPECT() *MockIService_Expecter {
	return &MockIService_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type MockIService
func (_mock *MockIService) Add(item *fooditem.FoodItem) (*fooditem.FoodItem, error) {
	ret := _mock.Called(item)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 *fooditem.FoodItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*fooditem.FoodItem) (*fooditem.FoodItem, error)); ok {
		return returnFunc(item)
	}
	if returnFunc, ok := ret.Get(0).(func(*fooditem.FoodItem) *fooditem.FoodItem); ok {
		r0 = returnFunc(item)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fooditem.FoodItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*fooditem.FoodItem) error); ok {
		r1 = returnFunc(item)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIService_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockIService_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - item *fooditem.FoodItem
func (_e *MockIService_Expecter) Add(item interface{}) *MockIService_Add_Call {
	return &MockIService_Add_Call{Call: _e.mock.On("Add", item)}
}

func (_c *MockIService_Add_Call) Run(run func(item *fooditem.FoodItem)) *MockIService_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *fooditem.FoodItem
		if args[0] != nil {
			arg0 = args[0].(*fooditem.FoodItem)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIService_Add_Call) Return(foodItem *fooditem.FoodItem, err error) *MockIService_Add_Call {
	_c.Call.Return(foodItem, err)
	return _c
}

func (_c *MockIService_Add_Call) RunAndReturn(run func(item *fooditem.FoodItem) (*fooditem.FoodItem, error)) *MockIService_Add_Call {
	_c.Call.Return(run)
	return _c
}

// AddMicronutrient provides a mock function for the type MockIService
func (_mock *MockIService) AddMicronutrient(item *fooditem.Micronutrient, foodItemID int64, ownerID int64) (*fooditem.Micronutrient, error) {
	ret := _mock.Called(item, foodItemID, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for AddMicronutrient")
	}

	var r0 *fooditem.Micronutrient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*fooditem.Micronutrient, int64, int64) (*fooditem.Micronutrient, error)); ok {
		return returnFunc(item, foodItemID, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(*fooditem.Micronutrient, int64, int64) *fooditem.Micronutrient); ok {
		r0 = returnFunc(item, foodItemID, ownerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fooditem.Micronutrient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*fooditem.Micronutrient, int64, int64) error); ok {
		r1 = returnFunc(item, foodItemID, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIService_AddMicronutrient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMicronutrient'
type MockIService_AddMicronutrient_Call struct {
	*mock.Call
}

// AddMicronutrient is a helper method to define mock.On call
//   - item *fooditem.Micronutrient
//   - foodItemID int64
//   - ownerID int64
func (_e *MockIService_Expecter) AddMicronutrient(item interface{}, foodItemID interface{}, ownerID interface{}) *MockIService_AddMicronutrient_Call {
	return &MockIService_AddMicronutrient_Call{Call: _e.mock.On("AddMicronutrient", item, foodItemID, ownerID)}
}

func (_c *MockIService_AddMicronutrient_Call) Run(run func(item *fooditem.Micronutrient, foodItemID int64, ownerID int64)) *MockIService_AddMicronutrient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *fooditem.Micronutrient
		if args[0] != nil {
			arg0 = args[0].(*fooditem.Micronutrient)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIService_AddMicronutrient_Call) Return(micronutrient *fooditem.Micronutrient, err error) *MockIService_AddMicronutrient_Call {
	_c.Call.Return(micronutrient, err)
	return _c
}

func (_c *MockIService_AddMicronutrient_Call) RunAndReturn(run func(item *fooditem.Micronutrient, foodItemID int64, ownerID int64) (*fooditem.Micronutrient, error)) *MockIService_AddMicronutrient_Call {
	_c.Call.Return(run)
	return _c
}

// AddPortionSize provides a mock function for the type MockIService
func (_mock *MockIService) AddPortionSize(item *fooditem.PortionSize, foodItemID int64, ownerID int64) (*fooditem.PortionSize, error) {
	ret := _mock.Called(item, foodItemID, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for AddPortionSize")
	}

	var r0 *fooditem.PortionSize
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*fooditem.PortionSize, int64, int64) (*fooditem.PortionSize, error)); ok {
		return returnFunc(item, foodItemID, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(*fooditem.PortionSize, int64, int64) *fooditem.PortionSize); ok {
		r0 = returnFunc(item, foodItemID, ownerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fooditem.PortionSize)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*fooditem.PortionSize, int64, int64) error); ok {
		r1 = returnFunc(item, foodItemID, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIService_AddPortionSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPortionSize'
type MockIService_AddPortionSize_Call struct {
	*mock.Call
}

// AddPortionSize is a helper method to define mock.On call
//   - item *fooditem.PortionSize
//   - foodItemID int64
//   - ownerID int64
func (_e *MockIService_Expecter) AddPortionSize(item interface{}, foodItemID interface{}, ownerID interface{}) *MockIService_AddPortionSize_Call {
	return &MockIService_AddPortionSize_Call{Call: _e.mock.On("AddPortionSize", item, foodItemID, ownerID)}
}

func (_c *MockIService_AddPortionSize_Call) Run(run func(item *fooditem.PortionSize, foodItemID int64, ownerID int64)) *MockIService_AddPortionSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *fooditem.PortionSize
		if args[0] != nil {
			arg0 = args[0].(*fooditem.PortionSize)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIService_AddPortionSize_Call) Return(portionSize *fooditem.PortionSize, err error) *MockIService_AddPortionSize_Call {
	_c.Call.Return(portionSize, err)
	return _c
}

func (_c *MockIService_AddPortionSize_Call) RunAndReturn(run func(item *fooditem.PortionSize, foodItemID int64, ownerID int64) (*fooditem.PortionSize, error)) *MockIService_AddPortionSize_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockIService
func (_mock *MockIService) Delete(id int64, ownerID int64) error {
	ret := _mock.Called(id, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int64, int64) error); ok {
		r0 = returnFunc(id, ownerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIService_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockIService_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - id int64
//   - ownerID int64
func (_e *MockIService_Expecter) Delete(id interface{}, ownerID interface{}) *MockIService_Delete_Call {
	return &MockIService_Delete_Call{Call: _e.mock.On("Delete", id, ownerID)}
}

func (_c *MockIService_Delete_Call) Run(run func(id int64, ownerID int64)) *MockIService_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIService_Delete_Call) Return(err error) *MockIService_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIService_Delete_Call) RunAndReturn(run func(id int64, ownerID int64) error) *MockIService_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockIService
func (_mock *MockIService) Get(ownerID int64) ([]*fooditem.FoodItem, error) {
	ret := _mock.Called(ownerID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []*fooditem.FoodItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) ([]*fooditem.FoodItem, error)); ok {
		return returnFunc(ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) []*fooditem.FoodItem); ok {
		r0 = returnFunc(ownerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fooditem.FoodItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIService_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockIService_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ownerID int64
func (_e *MockIService_Expecter) Get(ownerID interface{}) *MockIService_Get_Call {
	return &MockIService_Get_Call{Call: _e.mock.On("Get", ownerID)}
}

func (_c *MockIService_Get_Call) Run(run func(ownerID int64)) *MockIService_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIService_Get_Call) Return(foodItems []*fooditem.FoodItem, err error) *MockIService_Get_Call {
	_c.Call.Return(foodItems, err)
	return _c
}

func (_c *MockIService_Get_Call) RunAndReturn(run func(ownerID int64) ([]*fooditem.FoodItem, error)) *MockIService_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockIService
func (_mock *MockIService) GetByID(id int64) (*fooditem.FoodItem, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *fooditem.FoodItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*fooditem.FoodItem, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *fooditem.FoodItem); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fooditem.FoodItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIService_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockIService_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id int64
func (_e *MockIService_Expecter) GetByID(id interface{}) *MockIService_GetByID_Call {
	return &MockIService_GetByID_Call{Call: _e.mock.On("GetByID", id)}
}

func (_c *MockIService_GetByID_Call) Run(run func(id int64)) *MockIService_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIService_GetByID_Call) Return(foodItem *fooditem.FoodItem, err error) *MockIService_GetByID_Call {
	_c.Call.Return(foodItem, err)
	return _c
}

func (_c *MockIService_GetByID_Call) RunAndReturn(run func(id int64) (*fooditem.FoodItem, error)) *MockIService_GetByID_Call {
	_c.Call.Return(run)
	return _c
}
